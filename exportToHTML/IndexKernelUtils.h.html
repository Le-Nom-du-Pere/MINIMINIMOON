<html>
<head>
<title>IndexKernelUtils.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #333333;}
.s1 { color: #000080; font-weight: bold;}
.s2 { color: #660e7a; font-weight: bold;}
.s3 { color: #0086b3;}
.s4 { color: #969896; font-style: italic;}
.ln { color: #333333; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
IndexKernelUtils.h</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a>
<a name="l2"><span class="ln">2    </span></a><span class="s1">#include </span><span class="s0">&lt;cstdint&gt;</span>
<a name="l3"><span class="ln">3    </span></a><span class="s1">#include </span><span class="s0">&lt;ATen/native/TensorIterator.h&gt;</span>
<a name="l4"><span class="ln">4    </span></a><span class="s1">#include </span><span class="s0">&lt;ATen/native/cuda/MemoryAccess.cuh&gt;</span>
<a name="l5"><span class="ln">5    </span></a>
<a name="l6"><span class="ln">6    </span></a><span class="s2">namespace </span><span class="s0">at::native {</span>
<a name="l7"><span class="ln">7    </span></a>
<a name="l8"><span class="ln">8    </span></a><span class="s0">template&lt;</span><span class="s1">int </span><span class="s0">alignment&gt;</span>
<a name="l9"><span class="ln">9    </span></a><span class="s2">inline </span><span class="s1">bool </span><span class="s0">fast_gather_kernel_eligible(</span><span class="s1">const </span><span class="s0">TensorIterator&amp; iter, </span><span class="s1">char </span><span class="s0">* </span><span class="s1">const </span><span class="s0">out_ptr, </span><span class="s1">char </span><span class="s0">* </span><span class="s1">const </span><span class="s0">in_ptr, </span><span class="s1">const </span><span class="s0">size_t index_stride_bytes, </span><span class="s1">const </span><span class="s0">size_t element_size) {</span>
<a name="l10"><span class="ln">10   </span></a>  <span class="s2">using </span><span class="s0">at::native::memory::get_alignment;</span>
<a name="l11"><span class="ln">11   </span></a>  <span class="s1">const auto </span><span class="s0">index_element_size = iter.element_size(</span><span class="s3">2</span><span class="s0">);</span>
<a name="l12"><span class="ln">12   </span></a>  <span class="s4">//TensorIterator strides and sizes are ordered fastest moving to slowest moving,</span>
<a name="l13"><span class="ln">13   </span></a>  <span class="s4">//in contrast to regular sizes</span>
<a name="l14"><span class="ln">14   </span></a>  <span class="s4">// we need contiguous source and dst slices and aligned pointers and strides and slice size to do vectorized loads</span>
<a name="l15"><span class="ln">15   </span></a>  <span class="s4">// also we need idx to be expanded in the last dimension so we can copy entire slices</span>
<a name="l16"><span class="ln">16   </span></a>  <span class="s4">// and we need the src tensor to keep 0 stride from restriding</span>
<a name="l17"><span class="ln">17   </span></a>  <span class="s4">// (it could have been deleted by dimension collapse, in this case iterator would still be 2d</span>
<a name="l18"><span class="ln">18   </span></a>  <span class="s4">// but we cannot use fast path)</span>
<a name="l19"><span class="ln">19   </span></a>
<a name="l20"><span class="ln">20   </span></a>  <span class="s1">return </span><span class="s0">iter.ndim() == </span><span class="s3">2 </span><span class="s0">&amp;&amp; iter.strides(</span><span class="s3">2</span><span class="s0">)[</span><span class="s3">0</span><span class="s0">]==</span><span class="s3">0 </span><span class="s0">&amp;&amp; iter.strides(</span><span class="s3">2</span><span class="s0">)[</span><span class="s3">1</span><span class="s0">]==index_element_size &amp;&amp;</span>
<a name="l21"><span class="ln">21   </span></a>         <span class="s2">static_cast</span><span class="s0">&lt;size_t&gt;(iter.strides(</span><span class="s3">0</span><span class="s0">)[</span><span class="s3">0</span><span class="s0">])==element_size &amp;&amp;</span>
<a name="l22"><span class="ln">22   </span></a>         <span class="s2">static_cast</span><span class="s0">&lt;size_t&gt;(iter.strides(</span><span class="s3">1</span><span class="s0">)[</span><span class="s3">0</span><span class="s0">])==element_size &amp;&amp; </span><span class="s2">static_cast</span><span class="s0">&lt;size_t&gt;(iter.strides(</span><span class="s3">1</span><span class="s0">)[</span><span class="s3">1</span><span class="s0">] == </span><span class="s3">0</span><span class="s0">) &amp;&amp;</span>
<a name="l23"><span class="ln">23   </span></a>         <span class="s0">get_alignment(out_ptr) == alignment &amp;&amp; get_alignment(in_ptr) == alignment &amp;&amp;</span>
<a name="l24"><span class="ln">24   </span></a>         <span class="s0">get_alignment(</span><span class="s2">static_cast</span><span class="s0">&lt;size_t&gt;(iter.shape()[</span><span class="s3">0</span><span class="s0">] * element_size)) == alignment &amp;&amp;</span>
<a name="l25"><span class="ln">25   </span></a>         <span class="s0">get_alignment(</span><span class="s2">static_cast</span><span class="s0">&lt;size_t&gt;(index_stride_bytes)) == alignment &amp;&amp;</span>
<a name="l26"><span class="ln">26   </span></a>         <span class="s0">get_alignment(</span><span class="s2">static_cast</span><span class="s0">&lt;size_t&gt;(iter.strides(</span><span class="s3">0</span><span class="s0">)[</span><span class="s3">1</span><span class="s0">])) == alignment;</span>
<a name="l27"><span class="ln">27   </span></a><span class="s0">}</span>
<a name="l28"><span class="ln">28   </span></a>
<a name="l29"><span class="ln">29   </span></a><span class="s0">template &lt;int64_t Alignment, </span><span class="s2">typename </span><span class="s0">index_t&gt;</span>
<a name="l30"><span class="ln">30   </span></a><span class="s1">void </span><span class="s0">vectorized_gather_kernel_launch(</span><span class="s1">char </span><span class="s0">* out, </span><span class="s1">char </span><span class="s0">* inp, index_t * idx, </span><span class="s1">int </span><span class="s0">num_ind,</span>
<a name="l31"><span class="ln">31   </span></a>                                     <span class="s0">int64_t slice_size_in_bytes, int64_t ind_dim_size, int64_t inp_stride_bytes, int64_t out_stride_bytes,</span>
<a name="l32"><span class="ln">32   </span></a>                                     <span class="s1">bool </span><span class="s0">allow_neg_indices=</span><span class="s1">false</span><span class="s0">);</span>
<a name="l33"><span class="ln">33   </span></a>
<a name="l34"><span class="ln">34   </span></a>
<a name="l35"><span class="ln">35   </span></a><span class="s0">}</span>
<a name="l36"><span class="ln">36   </span></a></pre>
</body>
</html>